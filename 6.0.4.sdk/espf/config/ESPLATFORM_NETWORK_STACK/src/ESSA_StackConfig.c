/*
 * Copyright (c) 2020-2022 EnduroSat AD. All rights reserved.
 *
 * Contents and presentations are protected world-wide.
 * Any kind of using, copying etc. is prohibited without prior permission.
 */
/**
 * @addtogroup ESPS_I
 * @{
 *
 * @file    ESSA_Stack_Config.c
 * @brief   ESPS Stack protocols configuration
 *
 * @}
 */

#include <stdint.h>
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/include/ESSA_Stack.h"
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/include/ESSA_FP.h"
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/Source/ESSA_ServiceProtocol_Impl.h"
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/Source/ESSA_MACTestProtocol.h"
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/Source/ESSA_BridgeDrvProtocol.h"
#include "config/ESPLATFORM_NETWORK_STACK/inc/ESSA_StackConfig.h"

// Header generated by CMake
#include "ESSA_StackConfigServices.h"

#if defined(MICROPYTHON_SERVICE_ENABLED)
    #include "upy_fp_gw.h"
#endif

// An array of protocol handlers.
static const ESSA_Stack_ProtocolInfo_t *fs_ProtocolCbkRegistry[] =
{
    FS_PROTOCOL_HANDLERS_LIST
};

// An array of protocol handlers of all the enabled services.
// FUNCTION_PROTOCOL_HANDLERS_LIST is generated by CMake, depending on the
// specified option (e.g. TELEMETRY_SERVICE_ENABLED)
static const ESSA_Stack_FunctionProtocolInfo_t *fs_FunctionProtocolCbkRegistry[] =
{
    FUNCTION_PROTOCOL_HANDLERS_LIST
};

static const ESSA_Stack_NetTypeCfg_t netTypeCfg[ESSASNETT_MAX] =
{
	{
		.pNetTypeHandler = &NETTYPE_HANDLER_ENTRY(ESSASNETT_INTERNAL, MAC_DrvEnqMessage),
		.mtu = ESSATMAC_MAX_DATA_SIZE,
	},
	{
		.pNetTypeHandler = &NETTYPE_HANDLER_ENTRY(ESSASNETT_AIR, MAC_DrvEnqMessage),
		.mtu = ESSATAIRMAC_MAX_PAYLOAD_SIZE
	},
	{
		.pNetTypeHandler = &NETTYPE_HANDLER_ENTRY(ESSASNETT_GS_TL_GW, cp_cmd_handler_mac_fp_gw_enq_message),
		.mtu = ESSATMAC_MAX_DATA_SIZE
	},
	{
		.pNetTypeHandler = &NETTYPE_HANDLER_ENTRY(ESSASNETT_UART_BRIDGE, MAC_DrvEnqMessage),
		.mtu = ESSATMAC_MAX_DATA_SIZE
	},
	{
		.pNetTypeHandler = &NETTYPE_HANDLER_ENTRY(ESSASNETT_UART_BRIDGE_LOCAL, MAC_DrvEnqMessage),
		.mtu = ESSATMAC_MAX_DATA_SIZE
	},
#if defined(MICROPYTHON_SERVICE_ENABLED)
    {
        .pNetTypeHandler = &NETTYPE_HANDLER_ENTRY(ESSASNETT_MICROPYTHON_GW, upy_fp_gw_enq_message),
        .mtu = ESSATMAC_MAX_DATA_SIZE
    },
#endif
};

void ESSA_StackConfig_Init(void)
{
	static const ESSA_Stack_Ctx_t stack_cfg =
	{
		.ppProtocolCollection = fs_ProtocolCbkRegistry,
		.u16ProtocolCollectionSize = COUNT_OF(fs_ProtocolCbkRegistry),
		.p_nettype_cfg = netTypeCfg,
		.su16NetTypeHandlersSize = ESSASNETT_MAX
	};

	static const ESSA_Stack_FP_Ctx_t fp_cfg =
	{
		.ppFunctionProtocolCollection = fs_FunctionProtocolCbkRegistry,
		.u16FunctionProtocolCollectionSize = COUNT_OF(fs_FunctionProtocolCbkRegistry),
	};

	(void) ESSA_Stack_FP_Init(&fp_cfg);
	(void) ESSA_Stack_Init(&stack_cfg);
}
