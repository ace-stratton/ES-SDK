/*
 * Copyright (c) 2020-2022 EnduroSat AD. All rights reserved.
 *
 * Contents and presentations are protected world-wide.
 * Any kind of using, copying etc. is prohibited without prior permission.
 */
/**
 * @addtogroup ESPS_I
 * @{
 *
 * @file    ESSA_Stack_Facade.c
 * @brief   Wrapper for the ESPS stack initialization definitions
 *
 * @}
 */

#include "es_cdef.h"
#include <esps_drv.h>
#include <esps_drv_config.h>
#include <esps_drv_dispatcher_thread.h>
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/include/ESSA_Stack.h"
#include "ESSA_Stack_TP_Layer.h"
#include "ESSA_ServiceProtocol_Handler.h"
#include "ESPLATFORM_NETWORK_STACK/ES_SAT_API/Source/ESSA_ServiceProtocol_Impl.h"
#include "cmsis_os2.h"
#include "TaskMonitor.h"
#include "ESSA_StackConfig.h"
// Header generated by CMake
#include "ESSA_StackConfigApps.h"

static osThreadId_t ESSA_SP_TaskHandle = NULL;
static const osThreadAttr_t ESSA_SP_Task_attributes =
{
  .name = "ESSA_SP_Task",
  .priority = (osPriority_t) osPriorityNormal,
  .stack_size = 4096
};

static void fs_vESSA_SP_Task(void *argument);

/** indicates whether the module is initialized or not */
static safe_bool_t is_module_initialized = SAFE_FALSE;

static void fs_vESSA_SP_Task(void *argument)
{
    #define TASK_PERIOD_MS     (50)
    #define WD_KICK_PERIOD     (2000)
    uint8_t u8AliveCntr = 0U;

    while (true)
    {
        ESSA_SP_Task();

        osDelay(TASK_PERIOD_MS);

        u8AliveCntr++;

        if ((u8AliveCntr * TASK_PERIOD_MS) >= WD_KICK_PERIOD)
        {
            u8AliveCntr = 0U;
            TaskMonitor_IamAlive(TASK_ESSA_SP_HANDLER);
            vApplicationLowStackCheck(TASK_ESSA_SP_HANDLER);
        }
    }
}

void ESSA_Stack_Facade_Init()
{
    // Start MAC driver
    MAC_bStartAllIfs(MACIF_INITTYPE_FULL);

    // Start Dispatcher threads
    for (uint8_t i = 0; i < eMAC_Interface_Count; i++)
        DISP_vThreadInit(MacCfg_u8GetStackIfId(i));

    ESSA_SP_Init(true);

    ESSA_StackConfig_Init();

    // Function generated by CMake
    ESSA_Stack_Services_Init();

    // initialise TP layer
    ESSA_Stack_TP_Layer_Init();

    for (uint8_t i = 0; i < eMAC_Interface_Count; i++)
        ESSASP_SendAnnounce(MacCfg_u8GetStackIfId(i));

    is_module_initialized = SAFE_TRUE;

    ESSA_SP_TaskHandle = osThreadNew(fs_vESSA_SP_Task, NULL, &ESSA_SP_Task_attributes);
    ESSASP_ASSERT(ESSA_SP_TaskHandle);

    TaskMonitor_TaskInitialized(TASK_ESSA_SP_HANDLER);
}

// Define for ESSASP_CB_GetDeviceInfo as part of the Service Protocol
uint8_t ESSATMAC_GetModuleAddr()
{
    // The address is assigned per MAC interface and one module may comprise several interfaces but for now
    // only one MAC address is used for all physical interfaces
    return MacCfg_u8GetMacAddress(eMAC_Interface_Primary);
}

safe_bool_t ESSA_Stack_Facade_Is_Init(void)
{
    return is_module_initialized;
}
