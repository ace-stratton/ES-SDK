/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmCommsMasterSvc.h>
#include "tctlmCubeNodeCommon1.h"

/*******************************************************************************
 ***************************  GLOBAL MACROS   **********************************
 ******************************************************************************/

/*******************************************************************************
 **************************   GLOBAL FUNCTIONS   *******************************
 ******************************************************************************/

 /* SET functions */

ErrorCode tctlmCubeNodeCommon1_setPowerSwitchState(TypeDef_TctlmEndpoint *endpoint, TctlmCubeNodeCommon1_SwitchState setVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 127;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 1)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0 = ((setVal & 0xFF) << 0);
        MEMCPY(&buffer[0], &prepare0, sizeof(U8));
        /*************************/
        bufferSizeUsed = 1;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    return result;
}


 /* GET functions */

ErrorCode tctlmCubeNodeCommon1_getPowerSwitchState(TypeDef_TctlmEndpoint *endpoint, TctlmCubeNodeCommon1_SwitchState *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 253;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 1)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 1)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0;
        MEMCPY(&prepare0, &buffer[0], sizeof(U8));
        *returnVal = (TctlmCubeNodeCommon1_SwitchState)((prepare0 >> 0) & 0xFF);
        if ((U8)*returnVal > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/

    return result;
}

ErrorCode tctlmCubeNodeCommon1_getHealthTlm(TypeDef_TctlmEndpoint *endpoint, TctlmCubeNodeCommon1_HealthTlm *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 254;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 14)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 14)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuCurrent, &buffer[0], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuTemp, &buffer[2], sizeof(S16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U16 prepare2;
        MEMCPY(&prepare2, &buffer[4], sizeof(U16));
        if (prepare2 > 5000)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
        returnVal->mcuVoltage = prepare2;
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->vBattCurrent, &buffer[6], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare4;
        MEMCPY(&prepare4, &buffer[8], sizeof(U8));
        returnVal->vBattOvercurrent = (Boolean)((prepare4 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(returnVal->watchdogCount, &buffer[9], 5);
    }
    /*************************/

    return result;
}

