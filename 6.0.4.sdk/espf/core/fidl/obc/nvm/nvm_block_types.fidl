package endurosat.pf

<** @description: OBC NVM block configuration types
    @details: id = 111
**>
typeCollection helper_types
{
    <** @description: Increased-Hamming-distance-version of the regular boolean type. Used to represent regular boolean values.
    **>
    enumeration safe_bool
    {
        SAFE_FALSE = 0x00
        SAFE_TRUE = 0xFF
    }

    <** @details: size = 2 **>
    enumeration ModuleType
    {
        UNKNOWN = 0
        OBC_1016 = 5
        OBC2 = 6
    }

    <** @description: Settings for the telemetry service stored in the nvm **>
    struct tlm_preset_cfg
    {
        <** @description: DataCache-specified identifier **>
        UInt16 data_id
        <** @description: A flag indicating whether the data_id is part of the telemtry collection for this preset **>
        Boolean active
        <** @description: data acquistion period from the DataCache in sec **>
        UInt16 acq_period
    }
    
    enumeration tlm_file_cfg_type
    {
        SIZE_LIMIT = 0
        TIME_LIMIT = 1
    }
    
    struct bus_pull_up_state
    {
        Boolean pull_up_4k7
        Boolean pull_up_10k
    }

    enumeration aocs_log_data_types 
    {
        EST_ATT_ANGL,
        EST_ANG_RATES,
        MEAS_MAG_FIELD_VEC,
        EST_INNOVATION_VEC,
        Q_ERR_VEC,
        MAG_MCU_TEMP,
        RATE_SENS_TEMP,
        RATE_CONVERGENCE
    }    

    struct aocs_pm_parameters
    {
        <** @description: How much time we should log when we want to **> 
        UInt32 max_time_for_auto_log
        <** @description: Update interval it is uint8 because of requirements **>
        UInt8 update_interval
        <** @description: Data for assessment **>
        aocs_log_data_types data_type
        <** @description: Number of samples to skip when we do a maneuver **>
        UInt16 samples_to_skip
    }
    
    enumeration es_adcs_estimator
    {
        <** @description: No estimator algorithm executed **>
        ALGO_NONE
        <** @description: Estimator B-dot executed **>
        ALGO_BDOT_MAG        
    }

    struct es_adcs_estimator_config
    {
        <** @description: Array with executed estimators
            @details: size = 2 
        **>
        es_adcs_estimator[] eActiveEstimators    
    }

    enumeration es_adcs_controller
    {
        <** @description: No controller algorithm executed **>
        ALGO_NONE
        <** @description: Controller B-dot executed **>
        ALGO_BDOT_MAG
    }
    
    struct es_adcs_controller_bdot_config
    {
        Double bdot_coefficient_X
        Double bdot_coefficient_Y
        Double bdot_coefficient_Z
    }

    struct es_adcs_controller_config
    {
        <** @description: Executed controller **>
        es_adcs_controller ActiveController
        <** @description: B-dot specific configuration **>
        es_adcs_controller_bdot_config BdotConfig
    }

    enumeration es_adcs_used_magnetometer
    {
        ES_ADCS_USED_MAGNETOMETER_PRIMARY
        ES_ADCS_USED_MAGNETOMETER_SECONDARY
    }

    struct aocs_pm_threshold_values 
    {
        <** @description: Tolerance for performance **>
        Float tolerance
        <** @description: Safety factor is basically the tolerance of the tolerance **>
        Float safety_factor
    }

    enumeration es_coordsys_satellite_axes
    {
        SAT_X_AXIS_POSITIVE
        SAT_Y_AXIS_POSITIVE
        SAT_Z_AXIS_POSITIVE
        SAT_X_AXIS_NEGATIVE
        SAT_Y_AXIS_NEGATIVE
        SAT_Z_AXIS_NEGATIVE
    }

    struct es_coordsys_gyr_frame
    {
        <** @description: Which satellite axis does gyroscope 1 correspond to **>
        es_coordsys_satellite_axes gyr1
        <** @description: Which satellite axis does gyroscope 2 correspond to **>
        es_coordsys_satellite_axes gyr2
        <** @description: Which satellite axis does gyroscope 3 correspond to **>
        es_coordsys_satellite_axes gyr3
    }
    
    struct es_coordsys_mag_frame
    {
        <** @description: Which satellite axis does magnetometer X axis correspond to **>
        es_coordsys_satellite_axes mag_x
        <** @description: Which satellite axis does magnetometer Y axis correspond to **>
        es_coordsys_satellite_axes mag_y
        <** @description: Which satellite axis does magnetometer Z axis correspond to **>
        es_coordsys_satellite_axes mag_z
    }

    struct es_coordsys_mtq_frame
    {
        <** @description: Which satellite axis does magnetorquer 1 correspond to **>
        es_coordsys_satellite_axes mtq1
        <** @description: Which satellite axis does magnetorquer 2 correspond to **>
        es_coordsys_satellite_axes mtq2
        <** @description: Which satellite axis does magnetorquer 3 correspond to **>
        es_coordsys_satellite_axes mtq3
    }
    
    struct es_coordsys_css_frame
    {
        <** @description: Which satellite axis does coarse sun sensor 1 correspond to **>
        es_coordsys_satellite_axes css1
        <** @description: Which satellite axis does coarse sun sensor 2 correspond to **>
        es_coordsys_satellite_axes css2
        <** @description: Which satellite axis does coarse sun sensor 3 correspond to **>
        es_coordsys_satellite_axes css3
        <** @description: Which satellite axis does coarse sun sensor 4 correspond to **>
        es_coordsys_satellite_axes css4
        <** @description: Which satellite axis does coarse sun sensor 5 correspond to **>
        es_coordsys_satellite_axes css5
        <** @description: Which satellite axis does coarse sun sensor 6 correspond to **>
        es_coordsys_satellite_axes css6
    }

    struct es_coordsys_acc_frame
    {
        <** @description: Which satellite axis does accelerometer X axis correspond to **>
        es_coordsys_satellite_axes acc_x
        <** @description: Which satellite axis does accelerometer Y axis correspond to **>
        es_coordsys_satellite_axes acc_y
        <** @description: Which satellite axis does accelerometer Z axis correspond to **>
        es_coordsys_satellite_axes acc_z
    }

    enumeration TIME_calp_pulses
    {
        RESET = 0
        SET = 1
    }

    struct sds_events_cfg
    {
		<** @description: Frequency configuration in [Hz] **>
        UInt16 freq_cfg
		<** @description: Sensor type configuration **>
        UInt16 event_cfg
    }

    enumeration gyroscope_number
    {
        GYROSCOPE_1 = 1
        GYROSCOPE_2 = 2
        GYROSCOPE_3 = 3
    }
    
    enumeration gyroscope_status
    {
        GYRO_SUCCESS,                     /**< Gyroscope operation passed successfully */
        GYRO_NOT_INIT,                    /**< Gyroscope has not been initialized */
        GYRO_INIT_X_NOT_FOUND,            /**< Gyroscope X axis was not found in NVM during initialization */
        GYRO_INIT_Y_NOT_FOUND,            /**< Gyroscope Y axis was not found in NVM during initialization */
        GYRO_INIT_Z_NOT_FOUND,            /**< Gyroscope Z axis was not found in NVM during initialization */
        GYRO_INIT_AXIS_NOT_FOUND_IN_NVM,  /**< Desired gyroscope axis was not found in NVM configurations */
        GYRO_COMM_READ_FAIL,              /**< Reading from gyroscope registers failed */
        GYRO_COMM_WRITE_FAIL,             /**< Writing to gyroscope registers failed */
        GYRO_COMM_SPI_R_FAIL,             /**< SPI read from gyroscope failed */
        GYRO_COMM_SPI_W_FAIL,             /**< SPI write to gyroscope failed */
        GYRO_PROD_ID_ERROR,               /**< Incorrect product id of gyroscope */
        GYRO_MEASURE_OUT_OF_RANGE,        /**< Gyroscope measurement was out of expected range */
        GYRO_ATTEMPTS_EXPIRED,            /**< Gyroscope has failed to provide data within the defined attempt limit */
        GYRO_DISABLED,                    /**< Gyroscope is disabled (enabledFlag is 0) */
        GYRO_DISCONNECTED,                /**< Gyroscope has been disconnected (enabledFlag is 1, but invalid reading) */
        GYRO_ERROR                        /**< Gyroscope general error, returned when reading operation failed on all gyroscopes */
    }
    
    enumeration Panel_Number
    {
        <** @description: Panel connected to output connector designated PAN_1 **> 
        PANEL_1 = 1
        <** @description: Panel connected to output connector designated PAN_2 **> 
        PANEL_2 = 2
        <** @description: Panel connected to output connector designated PAN_3 **>
        PANEL_3 = 3
        <** @description: Panel connected to output connector designated PAN_4 **>
        PANEL_4 = 4
        <** @description: Panel connected to output connector designated PAN_5 **>
        PANEL_5 = 5
        <** @description: Panel connected to output connector designated PAN_6 **>
        PANEL_6 = 6
    }
    
    enumeration PanId
    {
        PAN_X_P
        PAN_Y_P
        PAN_Z_P
        PAN_X_M
        PAN_Y_M
        PAN_Z_M
    }
    
    struct gyroscope
    {
        gyroscope_number gyro_id
        gyroscope_status generalStatus
        <** @description: Physical panel that this gyroscope is attached to **>
        Panel_Number attachedPanel
        <** @description: Software defined coordinate frame axis that this gyroscope is connected to **>
        PanId satelliteAxis
        <** @description: Flag that determines whether the gyroscope is enabled (used) or disabled (unused) **> 
        UInt8 enabledFlag
    }
    
    enumeration CubeADCS_CfgType
    {
        PWR_UP
        NORMAL_DETUMBLING
        Y_THOMSON
        Y_THOMSON_MEMS_RATE
        FAST_DETUMBLING
        VERY_FAST_DETUMBLING
        Y_MOMENTUM
        Y_MOMENTUM_FULL_STATE_EKF
        THREE_AXIS
        SUN_TRACKING
        TARGET_TRACKING
        NO_CONTROL
        ATTITUDE_CHANGE
        ORBITAL_CHANGE
        GEO_TARGET_TRACKING
    }

    enumeration CUBE_ADCS_TC_13_CONTROL_MODE 
    {
        NO_CNTRL
        DETUMB_CNTRL
        Y_THOMPSON
        Y_WHEEL_INITIAL
        Y_WHEEL_STEADY
        XYZ_WHEEL_CNTRL
        RWHEEL_SUN_TRACKING
        RWHEEL_TARGET_TRACKING
        VERY_FAST_SPIN_DETUMB
        FAST_SPIN_DETUMB
        USER_MODE_1
        USER_MODE_2
        STOP_R_WHEELS
        USER_CODED_MODE
        SUN_TRACKING_YAW_OR_ROLL_ONLY
        TARGET_TRACKING_YAW_ONLY
    }

    enumeration CUBE_ADCS_TC_14_ESTIMATION_MODE 
    {
        NO_EST
        MEMS_RATE_SENS
        MTM_RATE_FILT
        MTM_RATE_FILT_WITH_PITCH
        MTM_FINE_SUN_TRIAD
        FULL_EKF
        MEMS_GYRO_EKF
        USR_CODED
    }
    
    enumeration CUBE_ADCS_TC_10_RUNMODE 
    {
        RUNMODE_OFF
        RUNMODE_ENABLED
        RUNMODE_TRIGGERED
        RUNMODE_SIMULATION
    }
    
    struct CubeADCS_Cfg
    {
        helper_types.CubeADCS_CfgType CfgType
        <** @description: Bit-mask (LSB first)
                CubeControl_Signal  : 1;
                CubeControl_Motor   : 1;
                CubeSense1          : 1;
                CubeSense2          : 1;
                CubeStar            : 1;
                CubeWheel1          : 1;
                CubeWheel2          : 1;
                CubeWheel3          : 1;
                MotorPwr            : 1;
                GPSPwr              : 1;
                Res                 : 6;
        **>
        UInt16 NodePwrMask
        helper_types.CUBE_ADCS_TC_13_CONTROL_MODE CntrlMask
        helper_types.CUBE_ADCS_TC_14_ESTIMATION_MODE EstMode
        helper_types.CUBE_ADCS_TC_10_RUNMODE RunMask
        UInt8 AdditionalLogic
    }
    <** @description: Index for the MAC Address book
        @details: size = 1
    **>
    enumeration mac_address_index
    {
        <** @description: EPS I ESPS bus MAC address **>
        MAC_ADDR_EPS_I,
        <** @description: EPS II Battery Pack ESPS bus MAC address **>
        MAC_ADDR_EPS_II_BP,
        <** @description: EPS II PDM ESPS bus MAC address **>
        MAC_ADDR_EPS_II_PDM,
        <** @description: UHF ESPS bus MAC address **>
        MAC_ADDR_UHF,
        <** @description: SBand TMTC ESPS bus MAC address **>
        MAC_ADDR_SBAND_TMTC,
        <** @description: Solar Panel 1st slot ESPS bus MAC address **>
        MAC_ADDR_SP1,
        <** @description: Solar Panel 2nd slot  ESPS bus MAC address **>
        MAC_ADDR_SP2,
        <** @description: Solar Panel 3rd slot  ESPS bus MAC address **>
        MAC_ADDR_SP3,
        <** @description: Solar Panel 4th slot  ESPS bus MAC address **>
        MAC_ADDR_SP4,
        <** @description: Payload reserved slot 1 ESPS bus MAC address **>
        MAC_ADDR_PAYLOAD_1,
        <** @description: Payload reserved slot 2 ESPS bus MAC address **>
        MAC_ADDR_PAYLOAD_2,
        <** @description: Reserved slot ESPS bus MAC address **>
        MAC_ADDR_RESERVED_1,
        <** @description: Reserved slot ESPS bus MAC address **>
        MAC_ADDR_RESERVED_2,
        <** @description: Reserved slot ESPS bus MAC address **>
        MAC_ADDR_RESERVED_3,
        <** @description: Reserved slot ESPS bus MAC address **>
        MAC_ADDR_RESERVED_4
    }
}

typeCollection nvm_block_types
{
    version { major 0 minor 1 }

    <** @description: OBC persistent reset counters **>
    struct NvmBlock_BootData
    {
        UInt32 Reserve1
        UInt32 Mailbox
        UInt32 RST_WWD
        UInt32 RST_IWD
        UInt32 RST_LPR
        UInt32 RST_POR
        UInt32 RST_RstPin
        UInt32 RST_BOR
        UInt32 RST_HardFault
        UInt32 RST_MemFault
        UInt32 RST_BusFault
        UInt32 RST_UsageFault
        UInt32 RST_ErrHandler
        UInt32 RebootRequest
        UInt32 Reserve3
    }

    <** @description: Logistic information about the produced module **>
    struct NvmBlock_ModuleId
    {
        helper_types.ModuleType nModuleType
        UInt16 nModuleHWConfig
        UInt16 nModuleHWRevision
        <** @description: Module serial number (usually ASCII-formatted) 
            @details: size = 30 
        **>
        UInt8[] szModuleSerial
    }

    <** @description: ESPS bus configuration for the OBC **>
    struct NvmBlock_MacConfig
    {
        <** @description: LSBit 1 - System bus termination setting; LSBit 2 - Payload bus termination setting **>
        UInt8 u8MacBusTerminationBitField
        <** @description: OBC ESPS bus MAC address **>
        UInt8 u8MacAddress
    }

    struct NvmBlock_beacons_cfg
    {
        <** @description: Controls whether the beacon feature is active or not **>
        helper_types.safe_bool beacons_en
        <** @description: Controls whether data can be sent over radio beacons in split-form, e.g. in multiple chunks **>
        helper_types.safe_bool chunk_based_transfer_en
        <** @description: Represents the beacon burst transmission period in units of [1 ms]. Beacon bursts are series of beacon frames. **>
        UInt32 bcn_tx_period
        <** @description: Represents the time period between beacon frames transmission in units of [1 ms].**>
        UInt32 bcn_inter_frame_period
    }

    struct NvmBlock_beacons_presets_cfg
    {
        <** @description: Specifies the different slot preset assignments of telemetry identifiers.
                          Presets can be changed at run-time depending on different conditions.
                          The size below is specified by calculating the number of slot presets slot_preset_cnt times
                          the maximum number of beacon messages max_bcn_msg_cnt in a single beacon sequence. This number
                          must match the number configured in the device firmware where this interface is
                          implemented. In this case, this is 4 presets consisting of 20 messages each.
                          The array is encoded as a 1D representation of a matrix where each row specifies all max_bcn_msg_cnt
                          message IDs for a single preset.
            @details: size = 80
        **>
        UInt16[] beacon_preset_cfg
    }

    struct NvmBlock_OpModesConfig
    {
		<** @description: Battery Capacity threshold in [mWh] for entrance into Safe Mode from any higher mode **>
        Int32 CBattSafe
		<** @description: Safety margin above Safe Mode after which the OBC can switch to IDLE mode, multiplier, ex. 1000 == 1.0 **>
        Int32 SSafe
		<** @description: Safety margin above Safe Mode after which the OBC can switch to Detumbling Mode, multiplier, ex. 1000 == 1.0 **>
        Int32 SDet
        <** @description: Safety margin above Safe Mode after which the OBC can switch to specific Payload Mode, multiplier, ex. 1000 == 1.0
			@details: size = 10 **>
        Int32[] SPay
		<** @description: Angular velocity in [mrad/s] after which the OBC can switch to Detumbling Mode, ex. 1200 == 1.2 rad/s **>
        Int32 AngVelMax
		<** @description: Angular velocity in [mrad/s] after which the OBC can switch from Detumbling mode (normal detumbling) to Safe mode, ex. 1200 == 1.2 rad/s **>
        Int32 AngVelLow
        <** @description: Angular velocity in [mrad/s]: Low < Yref < High, after which the OBC can switch from Detumbling mode (Y-Thomson) to Safe mode, ex. 1200 == 1.2 rad/s.
			@details: size = 2 **>
        Int32[] AngVelRange
    }

    struct NvmBlock_conops_idle_pointreq_cfg
    {
		<** @description: Enable/Disable sun-tracking in ConOps IDLE mode **>
        helper_types.safe_bool en_sun_tracking
    }

    struct NvmBlock_telemetry_cfg
    {
        <** @description: Controls whether the telemetry logging is active. Telemetry sink mechanisms are separately controlled but
                          if this flag is set to SAFE_FALSE, all sinks will cease operation.
        **>
        helper_types.safe_bool telemetry_en
        <** @description: Controls whether telemetry storage to files is active or not **>
        helper_types.safe_bool file_telemetry_en
    }

    struct NvmBlock_telemetry_preset_cfg
    {
        <** @description: Specifies the different slot preset assignments of telemetry identifiers.
                          Presets can be changed at run-time depending on different conditions.
                          The size below is specified by calculating the number of slot presets slot_preset_cnt times
                          the maximum number of Telemetry messages max_bcn_msg_cnt in a single Telemetry sequence. This number
                          must match the number configured in the device firmware where this interface is
                          implemented. In this case, this is 4 presets consisting of 20 messages each.
                          The array is encoded as a 1D representation of a matrix where each row specifies all max_bcn_msg_cnt
                          message IDs for a single preset.
            @details: size = 40
        **>
        helper_types.tlm_preset_cfg[] Telemetry_preset_cfg
    }

    struct NvmBlock_telemetry_file_cfg
    {
        helper_types.tlm_file_cfg_type cfg_type
        <** @description: Maximum size limit for all telemetry logged on the SD card **>
        UInt32 size_limit_kb
        <** @description: Number of individual files to split the log to **>
        UInt16 max_log_files_cnt
        <** @description: Maximum number of seconds of recent telemetry data to keep in the storage **>
        UInt32 time_limit_sec
        <** @description: Maximum size of individual log files **>
        UInt16 file_size_limit_kb
    }

    struct NvmBlock_EPSM_Config
    {
        helper_types.safe_bool enableRtcAutoAdjust
        helper_types.safe_bool onlyIfRtcIsLost
        helper_types.safe_bool reserved1
        helper_types.safe_bool enableCapacityCalculation
        helper_types.safe_bool enableUsingPduBoardTemperature
        helper_types.safe_bool usedExactTemperatureEnable
        Int16 exactTemperature
        helper_types.safe_bool reserved2
        helper_types.safe_bool allowAutoEnableEpsOnPowerUP
    }

    struct NvmBlock_cubeadcs_err_handl_cfg
    {
		<** @description: Enable/Disable the FDIR logic in the OBC related to the operation of CubeADCS Gen1 **>
        helper_types.safe_bool en_cubeadcs_err_handl    
    }

    struct NvmBlock_cubeadcs_status
    {
		<** @description: Commissioning value for CubeADCS Gen1. This value is used by the ConOps to check if certain logic (such as the automatic sun-tracking transition) can be activated. **>
        UInt8 commissioning
        <** @description: Value populated by the FDIR logic in the OBC in case a CubeADCS Gen1 node malfunctions. Each node occupies one bit and the byte spans the full number of available nodes in Gen1. **>
		UInt8 node_status
		<** @description: Value populated by the FDIR logic in the OBC in case a critical error in CubeADCS Gen1 is detected. Each error occupies one bit. **>
        UInt16 runtime_latched_errors
    }

    struct NvmBlock_i2c_config
    {
        <** @description: index 0 - Bus System; index 1 - Bus Payload
            @details: size = 2 
        **>
        helper_types.bus_pull_up_state[] i2c_pull_up_config
    }

    struct NvmBlock_cubeadcs_angle_limits
    {
		<** @description: Angle threshold value in [deg] used by certain CubeADCS Gen1 system states to confirm stable pointing has been achieved. **>
        Int32 stable_pointing_threshold_angle
		<** @description: Angular rate threshold value in [deg/s] used by certain CubeADCS Gen1 system states to confirm stable control has been achieved. **>		
        Int32 stable_pointing_threshold_angle_rate 
    }

    struct NvmBlock_aocs_pm_config
    {
        helper_types.aocs_pm_parameters parameters
    }

    struct NvmBlock_aocs_pm_threshold
    {
        <** @details: size = 3 **>
        helper_types.aocs_pm_threshold_values[] value
    }

    struct NvmBlock_es_adcs_config
    {
		<** @description: Estimator configuration **>
        helper_types.es_adcs_estimator_config EstimatorConfig
		<** @description: Controller configuration **>
        helper_types.es_adcs_controller_config ControllerConfig
        <** @description: The used magnetometer for estimation **>
        helper_types.es_adcs_used_magnetometer UsedMagnetometer
    }
    
    struct NvmBlock_es_coordsys_frames
    {
        helper_types.es_coordsys_gyr_frame gyroscopeFrame
        helper_types.es_coordsys_mag_frame magnetometerFrame
        helper_types.es_coordsys_mtq_frame magnetorquerFrame
        helper_types.es_coordsys_css_frame coarseSunSensorFrame
        helper_types.es_coordsys_acc_frame accelerometerFrame
    }

    struct NvmBlock_sds_sens_read_freq
    {
		<** @description: Value used to indicate if the sensor read logic should use the configured read frequencis. If the value is set to FALSE the sensors
				are read once per second and kept powered off in-between reads.**>
        helper_types.safe_bool enable
        <** @description: Frequency configuration in [Hz] and match to sensor type
			@details: size = 8 **>
        helper_types.sds_events_cfg[] sens_cfg
    }

    struct NvmBlock_crypto_cfg
    {
        <** @description: AES encryption key for internal crypto operations
            @details: size = 32 
        **>
        UInt8[] aes_key
    }

    struct NvmBlock_cubeadcs_sim_mode
    {
		<** @description: Enable/Disable simulation mode when CubeADCS Gen1 is connected to the OBC **>
        helper_types.safe_bool en_sim_mode
    }

    struct NvmBlock_rtc_calib_data
    {
        <** @description: RTC internal correction register offset value (see STM32H MCU datasheet)**>
        UInt16 calm
        <** @description: Direction of the applied offset (see STM32H MCU datasheet) **>
        helper_types.TIME_calp_pulses calp
    }
    
    struct NvmBlock_gyroscope_configs
    {
        <** @details: size = 3 **>
        helper_types.gyroscope[] gyroscopeArray
    }

    struct NvmBlock_ff_stats
    {
        <** @details: size = 20 **>
        UInt16[] ff_api_err_counters
    }

    struct NvmBlock_cubeADCS_sys_state_cfg
    {
        <** @description: CubeADCS Gen1 system state configurations. The system states aggregate the control mode, estimation mode, used nodes, etc. of CubeADCS Gen1 and facilitate the operation of the ADCS.
			@details: size = 15 **>
        helper_types.CubeADCS_Cfg[] CubeADCS_SysStates
    }
    
    struct NvmBlock_mac_address_book
    {
        <** @description: List of known MAC Addresses external to the OBC. 
			@details: size = 15 **>
        UInt8[] mac_address
    }
}
