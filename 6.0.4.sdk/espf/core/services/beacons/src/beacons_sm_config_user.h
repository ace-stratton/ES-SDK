/*
 * Copyright (c) 2020-2022 EnduroSat AD. All rights reserved.
 *
 * Contents and presentations are protected world-wide.
 * Any kind of using, copying etc. is prohibited without prior permission.
 */
#ifndef BEACONS_SM_CONFIG_USER_H
#define BEACONS_SM_CONFIG_USER_H

/** @addtogroup service_beacons
  * @{
  *
  * @file beacons_sm_config_user.h
  * @brief The file defines the shared types between the beacons service SM and the core implementation
  * @}
  */

#ifdef __cplusplus
extern "C" {
#endif

#include "libhsm.h"

// USER_CODE_START::@main@
#include <string.h>
#include "es_cdef.h"
#include "cmsis_os2.h"
#include "timer.h"
#include "beacon_types.h"
#include "if_beacons_sink.h"
#include "es_exeh.h"
#include "nvm/inc/nvm.h"

/** @typedef partial_msg_data_t
 *  @brief The type describes relevant data for the handling of a partial beacon message transfer and
 *  	   enables continuation of transfer between beacon frames.
 */
typedef struct
{
	safe_bool_t is_continuation_frame;		/**< this flag indicates the current beacon frame shall continue a transfer from the previous frame */
	uint32_t rem_msg_bytes_to_send;	/**< number of bytes remaining to send from the previous frame */
} partial_msg_data_t;

/** @typedef runtime_context_t
 *  @brief Runtime context information for the beacons service
 *
*/
typedef struct
{
	uint8_t active_beacon_frame[BEACON_FRAME_SIZE_BYTES];	/**< raw data buffer used for beacon preparation */
	uint8_t last_sink_frame_id;								/**< frame id generated by the sink adapter for the last send operation */
	safe_bool_t last_sink_frame_confirmed;					/**< indicates whether the last sink frame has been confirmed */
	uint8_t next_beacon_slot_idx_to_send;					/**< index in the @ref user_beacons vector of the next beacon message to send after last beacon frame is sent */
	osThreadId_t os_task_hnd;								/**< OS task handle */
	timer_handle_t send_timer;								/**< periodic send timer handle: the timer is used to track beacon periodic timing */
	timer_handle_t sink_confirm_timer;						/**< the timer is used to track sink confirmation timeouts */
	timer_handle_t inter_frame_timer;						/**< the timer is used to track inter-frame timeouts */
	timer_handle_t reload_config_timer;						/**< timer used to trigger reloading of NVM config while in stop mode */
	uint8_t beacon_frame_rolling_cntr;						/**< last used beacon frame rolling counter */
	beacons_cfg_t gen_cfg;									/**< general beacon configuration loaded from NVM */
	beacons_presets_cfg_t preset_cfg;						/**< preset configuration IDs loaded from NVM */
	uint8_t active_preset_id;								/**< currently used preset id for the beacon configuration */
	safe_bool_t more_messages_pending;						/**< indicates whether there are still unprocessed messages in the current beacon burst */
	partial_msg_data_t partial_msg_info;					/**< data used to manage beacon message continuation between frames */
} beacons_runtime_context_t;

/** @brief shared context between beacons.c and the SM implementation */
extern beacons_runtime_context_t beacons_rt_context;

/** @brief Beacon internal error codes reported to EXEH */
typedef enum
{
    EXEH_BCN_CANNOT_SPAWN_TASK,
	EXEH_BCN_SINK_ADAPTER_TIMEOUT
} exeh_error_codes_t;

/** @brief The function loads the beacon configuration from NVM */
void beacons_load_config(void);

// USER_CODE_END::@main@

// Entry/Exit functions
void beacons_sm_on_entry_Init(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_on_entry_Started(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_on_exit_Started(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_on_entry_Beacon_Wait_Time(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_on_entry_Stopped(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);

// Guard condition functions
bool beacons_sm_guard_can_stop_operation(sState_t* const pSMRoot, const sHSM_EventType_t * const pEvent);
bool beacons_sm_guard_is_beacon_time_expired(sState_t* const pSMRoot, const sHSM_EventType_t * const pEvent);
bool beacons_sm_guard_all_beacons_transmitted(sState_t* const pSMRoot, const sHSM_EventType_t * const pEvent);
bool beacons_sm_guard_is_sink_timeout_expired(sState_t* const pSMRoot, const sHSM_EventType_t * const pEvent);
bool beacons_sm_guard_can_continue_transmission(sState_t* const pSMRoot, const sHSM_EventType_t * const pEvent);

// Action handlers
void beacons_sm_action_reload_config(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_action_start_beacon_burst(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_action_reset_send_state(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_action_log_sink_timeout_error(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);
void beacons_sm_action_send_beacon(sState_t * const pSMRoot, const sHSM_EventType_t * const pEvent);

#ifdef __cplusplus
};
#endif

/**
 * @}
 * @}
 */
#endif  // #ifndef BEACONS_SM_CONFIG_USER_H
