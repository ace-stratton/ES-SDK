/*
 * Copyright (c) 2020-2022 EnduroSat AD. All rights reserved.
 *
 * Contents and presentations are protected world-wide.
 * Any kind of using, copying etc. is prohibited without prior permission.
 */
#ifndef ESPS_DRV_CT_H
#define ESPS_DRV_CT_H

/**
 * @addtogroup espsi_drv
 * @{
 *
 * @file     esps_drv_ct.h
 * @brief    MAC private C types
 *
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif

// External imports
#include "esps_drv_def.h"
#include "esps_drv_esps_stack.h"

#include "esps_drv_cdef.h"
#include "esps_drv_stats.h"
#include "esps_drv_tim.h"
#include "esps_drv_rcc.h"

#define RCV_MONITOR_WINDOWS_SIZE_BYTES  (1U)
#define MAC_TX_EVT_QUEUE_ELEM_COUNT     (5U)
#define MAC_TX_EVT_QUEUE_ELEM_SIZE      (sizeof(eTXEvent_t))

/** CRC32 seed value used for complete MAC frame CRC calculation */
#define CRC32_INIT_VALUE                ((uint32_t) 0xFFFFFFFF)

/******************************************************************************
 * Private Types
 *****************************************************************************/
/** Callback type for setting/resetting the DE pin. */
typedef void (*pfSetResetCb_t) (void);

struct sMACConfig_t;

/**< type for init or deinit callback of the MAC interface */
typedef void (*pfUartInitDeinitCb_t) (struct sMACConfig_t * cfg);

/**< Enumeration with receiver states */
typedef enum {
    eMACReceive_Off = 0U,       /**< The receiver is off */
    eMACReceive_Idle,           /**< The receiver is waiting for a new message */
    eMACReceive_NewMessage,     /**< The receiver is reading the rest of the header */
    eMACReceive_WaitAddress,    /**< The receiver is waiting for the address */
    eMACReceive_ReadHeader,     /**< The receiver is reading the header */
    eMACReceive_ReadData,       /**< The receiver is reading the data */
    eMACReceive_ReadCRC,        /**< The receiver is receiving the CRC */
    eMACReceive_DispatchMessage /**< The receiver is dispatching the full message */
} eMACReceiveState_t;

/** Enumeration with the transmitter states */
typedef enum {
    eMACTransmit_Off = 0U,
    eMACTransmit_Idle,          /**< TX is idle, waiting for a message to send */
    eMACTransmit_WaitPriority,  /**< TX is waiting for the priority time to pass */
    eMACTransmit_Active,        /**< TX of a message is ongoing */
    eMACTransmit_ProcessNext,   /**< TX is attempting to send the next message */
    eMACTransmit_Retry          /**< TX is retrying a message (decrements retry and/or priority) */
} eMACTransmitState_t;

/** Structure with the priority values */
typedef struct {
    uint8_t u8BasePriority; /**< base priority for the interface */
    uint8_t u8Priority;     /**< priority of the message */
} sMACPriority_t;

/** Memory pool type for a message to be transmitted */
typedef struct sMACTXPoolEntry_t {
    uint32_t nMsgID;    /**< Message identifier generated by the ESSA stack to be used in status callbacks for the enqueued Tx message */
    ESSATMAC_DrvResult_Cbk_t pSendCallback; /**< Status callback to notify stack about the transmission outcome */
    ESSATMAC_Message sMessage;  /**< The message to send */
    sMACPriority_t sPrio;       /**< Priority structure of the message */
    struct sMACTXPoolEntry_t *psNext; /**< Reference to the next message in the transmission queue */
} sMACTXPoolEntry_t;

/** Memory pool type for message reception */
typedef struct sMACRXPoolEntry_t {
    ESSATMAC_Message sMessage;        /**< The whole message received or pending reception */
    struct sMACRXPoolEntry_t *psNext; /**< Reference to the next message in the dispatch queue */
} sMACRXPoolEntry_t;

/** Dispatch queue structure holding the received messages but */
typedef struct {
    sMACRXPoolEntry_t *psHead;  /**< Head of the queue */
    sMACRXPoolEntry_t *psTail;  /**< Tail of the queue */
} sMACDispatchQueue;

/** Receive command type. Describes where the data should be stored */
typedef struct {
    uint8_t *pu8RXData;     /**< Buffer where to place the data */
    uint32_t u32RXSize;     /**< The amount of bytes to receive */
    uint32_t u32RXCount;    /**< The count of bytes already received */
} sMACReceiveCmd_t;

/** Enumeration with all events processed by the receiver state machine */
typedef enum {
    eRXEvent_None,              /**< NOP */
    eRXEvent_Activated,         /**< The Receiver is activated by calling the interface start function */
    eRXEvent_NewMessage,        /**< A new message is allocated */
    eRXEvent_WaitTimeout,       /**< A timeout event occurred */
    eRXEvent_AddressReceived,   /**< An address byte has been received */
    eRXEvent_AddressMissMatch,  /**< The address byte received does no match any know address */
    eRXEvent_ReceptionComplete, /**< A complete message has been received */
    eRXEvent_MessageDispatched, /**< The message has been dispatched */
    eRXEvent_TxOpStarted,       /**< Tx operation has started */
    eRXEvent_TxOpFinished,      /**< Tx operation finished */
    eRXEvent_RxError,           /**< Reception error occurred, e.g. noise/framing error or overrun */
    eRXEvent_MAX
} eRXEvent_t;

/** RX monitor structure. While transmitting the data received should match the transmitted data. */
typedef struct {
    uint16_t au16Log[RCV_MONITOR_WINDOWS_SIZE_BYTES]; /**< Log of bytes sent */
} sMACReceiveMonitor_t;

/** Receiver context structure. Aggregates every state data/value used by the receiver */
typedef struct {
    eMACReceiveState_t eState;      /**< The state of the receiver (@see eMACReceiveState_t) */
    eMACReceiveState_t ePrevState;  /**< Contains the last active SM state for the receiver */
    sMACRXPoolEntry_t *psMsgEntry;  /**< Reference to the message pool entry where the data is stored */
    sMACRXPoolEntry_t *pvMemPool;   /**< Pointer to the memory pool (points to aRxPool when initialized) */
    eRXEvent_t eStateEvent;         /**< The current state event to process */
    sMACReceiveCmd_t sRXCmd;        /**< Receiver command (@see sMACReceiveCmd_t) */
    uint32_t u32RxTimeSingle;       /**< Measured bus time in uS for the last received message */
    uint8_t u8NestLevel;            /**< Current nesting level for the fs_vRXState_ProcessEvent() function */
    bool bRS485BusReceiveEnabled;  /**< Keep status of the RS-485 bus */
    uint8_t aRxPool[MAC_RXMEMORYPOOL_COUNT][sizeof(sMACRXPoolEntry_t)]; /** RX memory pools array */
    bool aRxPoolFreeMap[MAC_RXMEMORYPOOL_COUNT]; /**< Array of bools to know what RX pools are occupied */
    uint8_t rxPoolsOccupied;    /**< Number of receive memory pools occupied */
} sMACReceiveCtx_t;

/** Transmitter command type. The transmission can be done with multiple
 *  commands to avoid latencies between sends (e.g. Send header, Send data, Send CRC)
 */
typedef struct {
    uint8_t *pu8TXData;     /**< Data to send */
    uint32_t u32TXSize;     /**< Amount of data to send */
    uint32_t u32TXCount;    /**< Count of bytes already sent */
} sMACTransmitCmd_t;

/** Enumeration with all event processed by the transmitter. */
typedef enum {
    eTXEvent_None,                  /**< NOP */
    eTXEvent_NewMessage,            /** A new message has been queued for sending */
    eTXEvent_CollisionDetected,     /**< A collision has been detected */
    eTXEvent_PriorityWaitFinished,  /**< The priority wait time has passed */
    eTXEvent_MessageSendFinished,   /**< Sending of the message has finished */
    eTXEvent_Retry,                 /**< A message should be retried */
    eTXEvent_QueueEmptied,          /**< The transmission queue is empty */
    eTXEvent_BusBusy,
    eTXEvent_MAX
} eTXEvent_t;

/** Structure with the transmitter context, aggregates all data needed for transmission */
typedef struct {
    eMACTransmitState_t eState; /**< State of the transmitter (@see eMACTransmitState_t) */
    eMACTransmitState_t ePrevState; /**< Contains the last active SM state for the transmitter */
    sMACTXPoolEntry_t *psQueue;     /**< Reference to the queue */
    uint32_t u32QueueElementsCount; /**< Counter of elements in the transmit queue */
    sMACTransmitCmd_t asTXCmds[MAC_TRANSMIT_MAX_CMD_COUNT]; /**< Transmission commands */
    sMACTXPoolEntry_t *psMsgEntry;  /**< The message currently being sent */
    sMACTXPoolEntry_t *pvMemPool;   /**< Pointer to the memory pool (points to aTxPool when initialized) */
    eTXEvent_t eStateEvent;         /**< The current state event to be processed */
    uint16_t u16TXCmdIdx;           /**< The index of the currently running transmission cmd */
    uint16_t u16TXCmdCount;         /**< The count of active transmission commands */
    uint32_t u32TxWaitTimeout;      /**< Accumulates the total time in ms for which a message was not able to start transmission */
    uint16_t u16TxRetries;          /**< Number of unsuccessful tries in a row (@see RS485_MAX_TX_RETRY_COUNT) */
    bool bSent;                     /**< Flag indicating whether or not the message was sent successfully */
    bool bRS485BusDriverEnabled;    /**< Keep status of the RS-485 bus */
    bool bEchoTimeoutElapsed;       /**< Flag indicating that a timeout or a cancel event occurred on the Tx echo monitoring */
    uint32_t u32TxTimeSingle;       /**< Measured bus time in uS for the last transmitted message */
    sMACReceiveMonitor_t sMonitor;  /**< Monitor instance */
    uint8_t u8NestLevel;            /**< Current nesting level for the fs_vTXState_ProcessEvent() function */
    uint8_t aTxPool[MAC_TXMEMORYPOOL_COUNT][sizeof(sMACTXPoolEntry_t)]; /** Array for the TX memory pool */
    bool aTxPoolFreeMap[MAC_TXMEMORYPOOL_COUNT]; /**< Array of bool to represent free TX Pools */
    uint8_t txPoolsOccupied;        /**< Counter of pools occupied */
} sMACTransmitCtx_t;

/** Structure with configuration values for a MAC interface */
typedef struct {
    USART_TypeDef *const psUART;    /**< The UART register base */
    const uint32_t u32Baudrate;     /**< UART Baudrate for the interface */
    const uint32_t u32NVICMask;     /**< NVIC interrupt mask to enable/disable the UART global interrupt */
    const uint32_t u32RCCMask;      /**< The RCC clock mask to enable/disable the peripherial */
    const eRCCPeripheralClock_t eClockSource; /**< The RCC clock source of the UART peripheral */
    const eTIMTimerID_t eTXTIMID;   /**< The TIM ID to use for transmission timing related tasks */
    const eTIMTimerID_t eRXTIMID;   /**< The TIM ID to use for reception timing related tasks */
    const uint16_t u16TQVal;        /**< Time quantum value in microseconds */
} sMACConfig_t;

/** Structure for received message dispatching */
typedef struct {
    sMACDispatchQueue sQueue;   /**< The dispatch queue for received messages */
    uint32_t u32RxMsgCount;     /**< Counter for messages waiting to be dispatched. @see MAC_bMessageInQueue */
    eMACInterface_t eMACId;     /**< MAC Interface ID */
} sMACDispatcher_t;

/** This structure contains parameters that will not be modifiable at runtime, it shall be placed in a FLASH section */
typedef struct {
    const pfSetResetCb_t pfEnableTX;    /**< Enable transmission callback */
    const pfSetResetCb_t pfDisableTX;   /**< Disable transmission callback */
    const pfSetResetCb_t pfEnableRX;    /**< Enable reception callback */
    const pfSetResetCb_t pfDisableRX;   /**< Disable reception callback */
    const sMACConfig_t sHwConfig;       /**< The static configuration of the UART/MAC */
    const pfUartInitDeinitCb_t pfUartInit; /**< UART init callback */
    const pfUartInitDeinitCb_t pfUartDeinit; /**< UART deinit callback */
} sMACInterfaceImmutableConfig_t;

/* MAC interface state structure. Aggregation of all needed data for reception and transmission */
typedef struct {
    const eMACInterface_t macIfId;  /**< ID of the MAC interface */
    uint16_t u16Address;            /**< Address of the MAC interface (used in 9 bit addressing mode) */
    const sMACInterfaceImmutableConfig_t *psCfg; /**< Pointer to the MAC Driver static configuration */
    sMACReceiveCtx_t sRXCtx;        /**< The reception context */
    sMACTransmitCtx_t sTXCtx;       /**< The transmission context */
    sMACDispatcher_t sDisp;         /**< Dispatcher */
    bool bInitDone;                 /**< Running or not flag */
    uint8_t u8BasePrio;             /**< Base priority for the interface */
    macStats_t macStats;            /**< MAC interface Rx/Tx stats */
    uint8_t criticalSectionNestLevel; /**< Nesting level counter for MAC driver critical sections */
} sMACInterfaceState_t;

#ifdef __cplusplus
}
#endif

#endif //ESPS_DRV_CT_H
