@startuml

title Sequence for message transmition and reception

participant APP as "User Application"
participant CFG as "MAC Config"
participant FP  as "ESPS I \nFunction Protocol"
participant ESS as "ESPS I library"
participant MAC as "ESPS I \nMAC Layer"
collections HAL as "ST HAL"

== initialization ==
note over HAL: initialize ST HAL
APP -> HAL: HAL_Init()
APP -> HAL: SystemClock_Config()

note over MAC: initialize MAC interfaces
APP -> MAC: MAC_bStartAllIfs()
activate MAC
CFG --> MAC: UART Configuration Definitions: fs_asMACStates
CFG --> MAC: Timers Configuration Definitions: TIM_CFG_asTimerEntries
MAC -> HAL: MAC_RNG_Init()
MAC -> HAL: MAC_TIM_bInit()
deactivate MAC

note over ESS: initialize the stack and the FP Callbacks
APP -> ESS: ESSA_Stack_Init()
activate ESS
ESS -> FP: <PROTOCOL>ClientAppInit()
ESS -> FP: <PROTOCOL>ServerAppInit()
deactivate ESS

== transmition of messages ==

note over APP: Send a request of certain protocol
APP -> FP: <PROTOCOL>_<COMMAND>Req()
FP -> ESS: ESSA_Stack_SendFrameEx()
ESS -> MAC: MAC_DrvEnqMessage()
note right MAC: The driver will send the message\n taking in account its priority\n and the bus traffic.
MAC-->APP: ESSATMAC_EC_OK

== reception of messages ==

note over APP: Loop to dispatch received messages
opt if MAC_bMessageInQueue(<interface ID>)
    note right APP: Get the interface instance from the drivers
    APP -> CFG: MacCfg_sGetMacInterfaceById(<interface ID>)
    activate CFG
    CFG --> APP: interface
    deactivate CFG
    note right APP: Dispatch, if any, the messages received in the interface
    APP -> MAC: MAC_DISP_vDispatchMessages(<interface>)
    activate MAC
    note right MAC: Verify that the MAC frame\n contains a valid message
    MAC -> MAC: MAC_bProtocolProcessMessage()
    MAC --> ESS: ESSA_Stack_DataDispatch()
    deactivate MAC
    ESS --> FP: fs_HandleData()
    FP --> APP: <PROTOCOL>_<COMMAND>RequestHandlerImpl()
else nothing to process
end opt

@enduml
