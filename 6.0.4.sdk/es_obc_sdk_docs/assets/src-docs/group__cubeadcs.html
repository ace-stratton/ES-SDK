<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnduroSat On-Board Computer SDK Documentation: CubeADCS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="../../index.html"><img alt="Logo" src="EnduroSat_horLogo_symbol@2x-min.png"/></a></td>
  <td id="projectalign">
   <div id="projectname">EnduroSat On-Board Computer SDK Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__cubeadcs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle"><div class="title">CubeADCS<div class="ingroups"><a class="el" href="group___drivers.html">Drivers</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:cubeadcs__cfg_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__cfg_8h.html">cubeadcs_cfg.h</a></td></tr>
<tr class="memdesc:cubeadcs__cfg_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurations specific to the CubeADCS. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__sysstate__cfg_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__sysstate__cfg_8c.html">cubeadcs_sysstate_cfg.c</a></td></tr>
<tr class="memdesc:cubeadcs__sysstate__cfg_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of the ADCS system states. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__sysstate__cfg_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__sysstate__cfg_8h.html">cubeadcs_sysstate_cfg.h</a></td></tr>
<tr class="memdesc:cubeadcs__sysstate__cfg_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration and types of the ADCS system state. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__version_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__version_8h.html">cubeadcs_version.h</a></td></tr>
<tr class="memdesc:cubeadcs__version_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CubeADCS logic version. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs_8h.html">cubeadcs.h</a></td></tr>
<tr class="memdesc:cubeadcs_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public interface of the CubeADCS. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__common__types_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__common__types_8h.html">cubeadcs_common_types.h</a></td></tr>
<tr class="memdesc:cubeadcs__common__types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commonly used types throughout the cubeadcs code base. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__crc_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__crc_8h.html">cubeadcs_crc.h</a></td></tr>
<tr class="memdesc:cubeadcs__crc_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of CRC calculations implementation specific to the CubeADCS. Used internally. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__driver_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__driver_8h.html">cubeadcs_driver.h</a></td></tr>
<tr class="memdesc:cubeadcs__driver_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the low-level driver dedicated to the CubeADCS module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__errhandl_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__errhandl_8h.html">cubeadcs_errhandl.h</a></td></tr>
<tr class="memdesc:cubeadcs__errhandl_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the error handling logic. Used internally by the CubeADCS logic if enabled. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__persist_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__persist_8h.html">cubeadcs_persist.h</a></td></tr>
<tr class="memdesc:cubeadcs__persist_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for use of the nvm related functions. Used internally. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__tc__tlm__descr_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__tc__tlm__descr_8h.html">cubeadcs_tc_tlm_descr.h</a></td></tr>
<tr class="memdesc:cubeadcs__tc__tlm__descr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types description used when requesting telemetry or telecommands. Based on CubeSpace's Firmware Reference Manual. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__usercmds_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__usercmds_8h.html">cubeadcs_usercmds.h</a></td></tr>
<tr class="memdesc:cubeadcs__usercmds_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the user commands. Used internally by the CubeADCS logic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs_8c.html">cubeadcs.c</a></td></tr>
<tr class="memdesc:cubeadcs_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main source file is the place of residence of the initialisation logic, the main task, functions related to getting/setting of the ADCS mode, control mode, estimation mode, etc. (commonly referred here as ADCS system state), functions related to sending commands and so on. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__crc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__crc_8c.html">cubeadcs_crc.c</a></td></tr>
<tr class="memdesc:cubeadcs__crc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions used to calculate the CRCs used throughout the CubeADCS logic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__driver_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__driver_8c.html">cubeadcs_driver.c</a></td></tr>
<tr class="memdesc:cubeadcs__driver_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level driver used to communicate with the CubeADCS over UART. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__errhandl_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__errhandl_8c.html">cubeadcs_errhandl.c</a></td></tr>
<tr class="memdesc:cubeadcs__errhandl_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of various error handling strategies based on errors reported by the CubeADCS. Use with caution, no fully tested. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__persist_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__persist_8c.html">cubeadcs_persist.c</a></td></tr>
<tr class="memdesc:cubeadcs__persist_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading and checking data from the NVM. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cubeadcs__usercmds_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cubeadcs__usercmds_8c.html">cubeadcs_usercmds.c</a></td></tr>
<tr class="memdesc:cubeadcs__usercmds_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the different commands exposed through the FP layer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The CubeADCS module provides integration for the (Gen1) 3-Axis/Y-Momentum ADCS solution provided by CubeSpace. The module includes:</p><ul>
<li>Low-level driver over UART</li>
<li>File-list download and file download logic implementation</li>
<li>Constant monitoring of the ADCS status and health</li>
<li>Support for quick Operational Modes integration</li>
<li>Error handling logic</li>
<li>Application level commands</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
Introduction</h2>
<p >This module consists of a low-level driver over UART and a mixed application/middleware layer distributed into several source and header files. Two tasks are used by the module - a file transfer task (normal priority), which deals with file downloads, uploads and file list downloads and a general task (again with normal priority) which takes care of the periodic health checks, errors, resets, etc. The current driver relies on a mutex to manage the access to the UART channel from overlapping requests to the CubeADCS which may occur from - the two tasks, user generic TC/TLM requests, Operational modes requests (read angular velocity, set new state for the CubeADCS, etc.). Typically, the response time of the CubeADCS is within a few [ms] which rarely results in a command request to fail.</p>
<dl class="section note"><dt>Note</dt><dd>If you perform command requests while a file transfer is ongoing the latter will probably fail as the transfer will be inhibited by the request. It is best to avoid this while performing file transfers.</dd></dl>
<h2><a class="anchor" id="autotoc_md26"></a>
The main task</h2>
<p >The main task implements a state machine which drives the periodic checks of the CubeADCS. The states of the state machine are depicted in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State Machine State   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">INIT_WAIT   </td><td class="markdownTableBodyNone">This is the state at power-up of the OBC. The task remains in this state for 10 seconds before moving to the INIT state. This wait is mandatory as it takes several seconds for the CubeADCS ACP to be booted by the CubeADCS Bootloader. If the wait is not there, the CubeADCS start-up sequence will be inhibited and the CubeADCS will remain in bootloader.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">INIT   </td><td class="markdownTableBodyNone">In this state the task sends a TLM128 request (identification telemetry) to assess if the CubeADCS has successfully started the ACP. In case the latter was not started, the state machine will remain in the INIT state indefinitely.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IDLE   </td><td class="markdownTableBodyNone">This is basically a wait state. The task remains in the IDLE state 10 seconds before continuing. This state also serves as the state transition state - if a request for a different state (such as reset is received) it will only be accepted if the current CubeADCS task state is IDLE. Once the 10 seconds elapse, the CubeADCS task switches to the Health Check state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">HEALTH_CHECK   </td><td class="markdownTableBodyNone">In this state telemetry regarding the current CubeADCS system state is gathered. The logic verifies that the current ADCS system state is the expected one, checks whether a switch to CubeACP in case we are in bootloader (it may happen in case the CubeADCS experiences a reset but the OBC does not) is necessary and calls the error handling implementation (this is performed always unless a switch to CubeACP is needed). At the end of the state the error counters are updated and, if necessary, a specific error handling logic is activated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SYSSTATE_CHANGE   </td><td class="markdownTableBodyNone">Performs a change of the state of the CubeADCS system → enables/disables nodes, changes control and estimation modes. Each pass through this state takes about 1 second and will be repeated no more than 5 times. The result of the state change attempt is written and can be read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PREP_DETUMB   </td><td class="markdownTableBodyNone">This state is called always after the HEALTH_CHECK state is passed. It serves the purpose to put the CubeADCS in a detumbling friendly state. Ideally, this state will be truly executed only once unless the CubeADCS undergoes a reset or is reset by a user command.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md27"></a>
The low-level driver</h2>
<p >The driver is responsible for sending commands and receiving telemetry from the CubeADCS via a dedicated UART channel. The driver is using the HAL library to perform transmit and receive. Data is transmitted by using blocking logic, but is received in a non-blocking manner (to this end a DMA channels is used). Several buffers are used for packing and unpacking of the data based on the CubeSpace protocol description. You can request fetch commands, transmit only, receive only and receive only in file download mode. Each receive or fetch request is marked by a non-blocking 1000 ms wait period in which the OBC waits to receive the correct number of bytes from the CubeADCS. The return from the execution of a request can be:</p>
<ul>
<li><b>COMM_OK</b>: Successful communication, no errors</li>
<li><b>COMM_ERR</b>: Unsuccessful communication, unspecified error</li>
<li><b>COMM_CMD_ERR</b>: Requested command ID not found in the list of known CubeADCS commands (the commands IDs, RX length and TX lengths are depicted in the driver sources)</li>
<li><b>COMM_LEN_WRT_ERR</b>: Expected vs given TC command data size mismatch</li>
<li><b>COMM_LEN_READ_ERR</b>: Expected vs received TC/TLM command data size mismatch</li>
<li><b>COMM_RX_TIMEOUT</b>: Timeout while receiving command request response</li>
<li><b>COMM_TX_TOMEUT</b>: Timeout while transmitting a command</li>
<li><b>COMM_INV_DATA</b>: Received correct number of bytes but command ID in header is not correct</li>
<li><b>COMM_COMM_ERR</b>: Error while receiving command request reply (wrong start/end sequence, etc.)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>These responses are featured in the error counters. Each time a command is sent, the reply is used to update the relevant error counter.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sometimes the CubeADCS response exceeds few hundred of milliseconds. Moreover, it happens that a response is never sent back. This accounts to a small number of COMM_RX_TIMEOUT replies from the driver.!!!</dd></dl>
<h2><a class="anchor" id="autotoc_md28"></a>
The CRC Calculation</h2>
<p >Two types of CRC (<b>CRC8</b> and <b>CRC16</b>) are used by CubeSpace. A <b>CRC8</b> is attached to telecommands and a <b>CRC16</b> is used during file transfers to check file consistency.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Error Handling</h2>
<dl class="section warning"><dt>Warning</dt><dd>This logic has a persistent configuration. By default this logic is turned <b>OFF</b> as it has not been thoroughly tested.</dd></dl>
<p>The automatic error handling logic consists of seventeen cases split into separate functions, taking care of the moderate and severe errors reported back by the CubeADCS. Each error handling logic can be activated once or several times and this is currently hardcoded. The limitation is put in place since, for example, there is no need to power cycle indefinitely an unresponsive node, or constantly change the magnetometer configuration. A table with all the errors that can be handled by the logic is depicted here:</p>
<p ><img src="../img/err_handl_logic.png" alt="Error Handling Logic" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md30"></a>
Handling Magnetometer Errors</h3>
<ul>
<li>Enables the CubeControl Motor MCU in order not to lose control and estimation</li>
<li>Power cycles the CubeControl Signal MCU on first error</li>
<li>Sample the redundant magnetometer on second error</li>
<li>Sample the main magnetometer with the CubeControl Motor MCU on third error</li>
<li>Raise the latched error flag to notify users on fourth error</li>
</ul>
<h3><a class="anchor" id="autotoc_md31"></a>
Handling Cam1, Cam2 and CamStar Errors</h3>
<ul>
<li>The logic for all camera nodes is currently identical</li>
<li>The faulty camera node is power cycled several times</li>
</ul>
<h3><a class="anchor" id="autotoc_md32"></a>
Handling Node Recovery Errors</h3>
<ul>
<li>Compares the currently enabled nodes with the nodes enabled by the OBC (but not the nodes enabled through the generic commands to the CubeADCS)</li>
<li>Stores the potential faulty node in a register and updates the status flag indicating this error has occurred</li>
</ul>
<h3><a class="anchor" id="autotoc_md33"></a>
Handling Rate Sensor and Wheel Errors</h3>
<ul>
<li>Stops all reaction wheels (By setting the RPM to 0)</li>
<li>Increases the rate sensor multiplier to maximize the rate sensor detection range</li>
<li>Enables both CubeControl MCUs</li>
<li>Sets the estimation mode to MEMS rate</li>
<li>Reads the angular rate and decides if fast or very fast detumbling should be activated</li>
</ul>
<h3><a class="anchor" id="autotoc_md34"></a>
Handling Rate Sensor Failure</h3>
<ul>
<li>Stops all reaction wheels (By setting the RPM to 0)</li>
<li>Enables CubeControl Signal MCU</li>
<li>Transition to Very Fast Detumbling mode if Signal MCU has been enabled</li>
<li>Transition to Fast Detumbling mode if Signal MCU has not been enabled</li>
</ul>
<h3><a class="anchor" id="autotoc_md35"></a>
Handling Orbit, Config, Estimation and Control Mode Errors</h3>
<p >No specific error handling logic is implemented.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Commands</h2>
<p >There are two types of CubeADCS commands:</p><ul>
<li>The first type are the commands which deal with the CubeADCS, but are implemented in the OBC. Details of these commands can be found in the fidl: <b>OBC_CUBEADCS.fidl</b>. Most are high-level functionality commands whcih are used to download files, read the operational status etc. There is a generic command which can be used to request almost any CubeADCS command. However, the data is presented raw.</li>
<li>The second type are the CubeADCS specific commands, their full description can be found in the <b>CubeADCS - Firmware Reference Manual [V7.2].pdf</b>. The fidl descriptions are in: <b>OBC_CP_CUBEADCS_GATEWAY.fidl</b>. These commands can be send only using the Command Protocol (CP).</li>
</ul>
<h2><a class="anchor" id="autotoc_md37"></a>
File Transfers</h2>
<p >File transfers are organized in a separate task which drives the state machines of the file transfer processes. Currently supported:</p><ul>
<li><span class="emoji">&#x2705;</span> File-list download</li>
<li><span class="emoji">&#x2705;</span> File downloads</li>
<li><span class="emoji">&#x274c;</span> File uploads (not implemented)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The implementation deals with the transfer of files between the OBC and the CubeADCS only. File transfers between the Ground Station and the OBC are not discussed here.</dd></dl>
<p>The CubeADCS supports a few file types (consult CubeSpace's documentation for further details). Therefore, files are downloaded to the OBC using a fixed naming convention:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Full File Name   </th><th class="markdownTableHeadNone">File Extension   </th><th class="markdownTableHeadNone">Details    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xxxCSTLM   </td><td class="markdownTableBodyNone">.txt   </td><td class="markdownTableBodyNone">Telemetry logs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xxxCSIMG   </td><td class="markdownTableBodyNone">.jpg   </td><td class="markdownTableBodyNone">Jpg images    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xxxCSIMG   </td><td class="markdownTableBodyNone">.bmp   </td><td class="markdownTableBodyNone">Bmp images    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xxxCSIND   </td><td class="markdownTableBodyNone">.txt   </td><td class="markdownTableBodyNone">Index file    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CSFL'IST   </td><td class="markdownTableBodyNone">.txt   </td><td class="markdownTableBodyNone">File list dump   </td></tr>
</table>
<p >, where <b>xxx</b> is the file type number.</p>
<p >Logs, images and the index file are downloaded as they are, but the file list is downloaded in a human readable format. An example file list has the structure depicted below, where <b>FileType</b> is given as a string (the actual file type) and as a number (each file type is associated with a number).</p>
<blockquote class="doxtable">
<p >&zwj;CubeADCS File List</p>
<p >FileType (s|d) Size CRC Time Ctr</p>
<p >Tlm | 2 0x00001D7A 0x181F 15/09/2044 13:49:22 000<br  />
Tlm | 2 0x0001A620 0x3E97 01/09/2021 11:48:10 001<br  />
Tlm | 2 0x00003E4A 0xBC2A 15/09/2044 13:37:30 002<br  />
Tlm | 2 0x000004EA 0x9E01 15/09/2044 13:38:00 003<br  />
Tlm | 2 0x00000E4A 0x6F19 15/09/2044 13:39:52 004<br  />
Tlm | 2 0x000000CA 0x0FD4 15/09/2044 13:29:48 005<br  />
</p>
</blockquote>
<p>When starting a file transfer, the user must provide information regarding the file which has to be downloaded. To uniquely identify a file and make a successful transfer, the following information is required:</p>
<ul>
<li>FileType</li>
<li>Counter</li>
<li>CRC16</li>
<li>FileSize</li>
<li>sdCardID</li>
</ul>
<p >There is no indication of the percentage of file downloaded, but the user can poll the status of the transfer. Typically, a file list download is almost instant, but a large file (~1MByte images) takes several minutes.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
The System State Configuration</h2>
<p >The CubeADCS is a system of its own with many different states and modes. However, from the perspective of the user (for example, the Operational Modes) the CubeADCS is <b>in a specific system state</b>. This state is described by:</p><ul>
<li>control mode</li>
<li>estimation mode</li>
<li>enabled periphery (nodes) To change these, several commands have to be sent to the CubeADCS coupled with relevant checks. Therefore, logic is implemented which will change these and make the necessary verification. The system states are populated in a configuration (array), which the user can extend.</li>
</ul>
<p >The array has the following structure: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structtag___cube_a_d_c_s___cfg.html">CubeADCS_Cfg_t</a> <a class="code hl_variable" href="cubeadcs__sysstate__cfg_8c.html#a229128567d88c889cf754305160e2c42">asCubeADCS_SysStates</a>[eCUBEADCS_CFGTYPE_NUMBER] = {</div>
<div class="line">      {     eCUBEADCS_CFGTYPE_PWR_UP,</div>
<div class="line">            { .CubeControl_Signal = 1,</div>
<div class="line">              .CubeControl_Motor  = 1,</div>
<div class="line">              .CubeSense1 = 0,</div>
<div class="line">              .CubeSense2 = 0,</div>
<div class="line">              .CubeStar   = 0,</div>
<div class="line">              .CubeWheel1 = 0,</div>
<div class="line">              .CubeWheel2 = 0,</div>
<div class="line">              .CubeWheel3 = 0</div>
<div class="line">            },</div>
<div class="line">            eCUBE_ADCS_TC_13_CONTROLMODE_NO_CNTRL,</div>
<div class="line">            eCUBE_ADCS_TC_14_ESTIMATIONMODE_MTM_RATE_FILT,</div>
<div class="line">            eCUBE_ADCS_TC10_RUNMODE_ENABLED,</div>
<div class="line">            0,</div>
<div class="line">      },</div>
<div class="line">      {     eCUBEADCS_CFGTYPE_NORMAL_DETUMBLING,</div>
<div class="line">            { .CubeControl_Signal = 1,</div>
<div class="line">              .CubeControl_Motor  = 1,</div>
<div class="line">              .CubeSense1 = 0,</div>
<div class="line">              .CubeSense2 = 0,</div>
<div class="line">              .CubeStar   = 0,</div>
<div class="line">              .CubeWheel1 = 0,</div>
<div class="line">              .CubeWheel2 = 0,</div>
<div class="line">              .CubeWheel3 = 0</div>
<div class="line">            },</div>
<div class="line">            eCUBE_ADCS_TC_13_CONTROLMODE_DETUMB_CNTRL,</div>
<div class="line">            eCUBE_ADCS_TC_14_ESTIMATIONMODE_MTM_RATE_FILT,</div>
<div class="line">            eCUBE_ADCS_TC10_RUNMODE_ENABLED,</div>
<div class="line">            0,</div>
<div class="line">      },</div>
<div class="line">      ...</div>
<div class="ttc" id="acubeadcs__sysstate__cfg_8c_html_a229128567d88c889cf754305160e2c42"><div class="ttname"><a href="cubeadcs__sysstate__cfg_8c.html#a229128567d88c889cf754305160e2c42">asCubeADCS_SysStates</a></div><div class="ttdeci">CubeADCS_Cfg_t asCubeADCS_SysStates[eCUBEADCS_CFGTYPE_NUMBER]</div><div class="ttdoc">CubeADCS system states description array.</div><div class="ttdef"><b>Definition:</b> <a href="cubeadcs__sysstate__cfg_8c_source.html#l00045">cubeadcs_sysstate_cfg.c:45</a></div></div>
<div class="ttc" id="astructtag___cube_a_d_c_s___cfg_html"><div class="ttname"><a href="structtag___cube_a_d_c_s___cfg.html">tag_CubeADCS_Cfg</a></div><div class="ttdef"><b>Definition:</b> <a href="cubeadcs__sysstate__cfg_8h_source.html#l00090">cubeadcs_sysstate_cfg.h:91</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>At power-up, the OBC instructs the CubeADCS to enter the <b>eCUBEADCS_CFGTYPE_PWR_UP</b> system state. In this state the necessary ADCS periphery to perform detumbling is enabled, but the control mode is <b>NOT</b> activated. However in case the error handling logic is enabled and the angular rates exceeds 100 deg/s, fast or very-fast detumbling will be enabled. This is independent of the system states changes, which are driven by a higher level logic such as the Operational Modes. </dd></dl>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by Doxygen 1.9.4 </li>
  </ul>
</div>
</body>
</html>
